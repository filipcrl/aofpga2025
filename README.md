# Advent of FPGA

This is my submission for the [2025 advent of FPGA competition](https://blog.janestreet.com/advent-of-fpga-challenge-2025/). I decided to solve the first part of problem 7.

## Running the project
In order to run the project.

```
opam install hardcaml ppx_hardcaml
dune test # to run test
```

## Introduction to the problem

In the seventh day of advent of code you are tasked with repairing the broken teleporter. In order to do this you must count the number of times the tachyon beam is split into two. Firstly a beam is generated from the 'S' symbol. If there is free space below it propagates downwards, if there is a splitter denominated by '^' it is split into two beams that are generated side by side.

```
.......S.......
.......|.......
......|^|......
...............
......^.^......
...............
.....^.^.^.....
...............
....^.^...^....
...............
...^.^...^.^...
...............
..^...^.....^..
...............
.^.^.^.^.^...^.
...............
```

## First attempt

The most obvious approach to solve this problem in hardware is to steam the lines, and keep the current state of the beams in a register. Then, the next state of the beams is a combinational function of the previous beam state, and of the current line of splitter and empty gaps. This is pictured for the second and third rows of the example in the following figure.
![Test image](/assets/combinational.png)

The issue with doing it this way is that the number of resources needed to implement the design on the FPGA grow with the width of the line. So if you want to process very long lines, you have to be prepared to spend a lot of money.

## Current implementation

In order to be able to process bigger lines without increasing the area used, my idea was to split each line into equally sized words. The resulting beam state would also be split into words, and stored inside dual-port bram memory that is available on many FPGAs. Data would be streamed in one word at a time.
